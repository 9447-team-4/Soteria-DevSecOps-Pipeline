# Argo CD

## ArgoCD Manifests

ArgoCD manifests for the pipeline

if you are running in minikube, run
`minikube start --vm-driver=hyperkit`

create namespace 'argocd' in minikube
`kubectl create namespace argocd`

Run the following command to install ArgoCD

`kubectl apply -n argocd -f ./path/to/install.yaml`

or

```
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.0.5/manifests/install.yaml
```

(You can check the status by running `kubectl -n argocd get pods`. Controller looks after all the app yamls we passed in.)

If something is running in port 8080
`sudo lsof -i :8080`
`kill -9 [process id]`

Run the following command to fast forward to localhost
`kubectl port-forward svc/argocd-server -n argocd 8080:443`

Run the following command to obtain the initial admin password for ArgoCD.
(When logging into the ArgoCD server, the initial id is set to '`admin`')

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo`

`chmod +x argocd_cli_auth.bash`
`./argocd_cli_auth.bash`

You may run `kubectl apply -n argocd -f ./path/to/your/app.yaml` to test deploying a sample app I provided in Soteria, else just create one in the ArgoCD UI.

## About ArgoCD CLI
For convenience, the argocd CLI can be downloaded directly from the API server. This is useful so that the CLI used in the CI pipeline is always kept in-sync and uses argocd binary that is always compatible with the Argo CD API server.

export ARGOCD_SERVER=argocd.mycompany.com
export ARGOCD_AUTH_TOKEN=<JWT token generated from project>
curl -sSL -o /usr/local/bin/argocd https://${ARGOCD_SERVER}/download/argocd-linux-amd64

If automated synchronization is configured for the application, this step is unnecessary. 
The controller will automatically detect the new config (fast tracked using a webhook, or polled every 3 minutes), and automatically sync the new manifests.


##  ArgoCD CLI to manually sync the App

`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app sync $APP_NAME --force`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app sync test-app --force`


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app wait $APP_NAME --timeout 600`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app wait test-app --timeout 600`

The above simply asks ArgoCD to trigger Kubernetes to deploy the app. Within ArgoCD, this is using the Manifest from the Git repository, that has been updated to use the new image tag. This will then go out and deploy a new version of it, based upon the image generated by the CI.

(Optional) kubectl commands to patch argocd-server



Patching the argocd-server to LoadBalancer
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'`

Patching the argocd-server to NodePort
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'`




## Usage in Gitea

When you are trying to connect the Gitea's git repository to ArgoCD, you should use a repo url such as below.

`http://{server_name}.{namespace}.svc.cluster.local:{portnumber}/path/to/your/deployment/repo.git`

e.g. `http://gitea-charts-http.default.svc.cluster.local:3000/haesun/Deployment.git`